
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>QREM.functions_qrem.povmtools &#8212; QREM 0.56 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for QREM.functions_qrem.povmtools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@authors: Filip Maciejewski, Oskar Słowik, Tomek Rybotycki</span>
<span class="sd">@contact: filip.b.maciejewski@gmail.com</span>

<span class="sd">References:</span>
<span class="sd">[0] Filip B. Maciejewski, Zoltán Zimborás, Michał Oszmaniec,</span>
<span class="sd">&quot;Mitigation of readout noise in near-term quantum devices</span>
<span class="sd">by classical post-processing based on detector tomography&quot;,</span>
<span class="sd">Quantum 4, 257 (2020)</span>

<span class="sd">[0.5] Filip B. Maciejewski, Flavio Baccari, Zoltán Zimborás, Michał Oszmaniec,</span>
<span class="sd">&quot;Modeling and mitigation of cross-talk effects in readout noise</span>
<span class="sd">with applications to the Quantum Approximate Optimization Algorithm&quot;,</span>
<span class="sd">Quantum 5, 464 (2021).</span>

<span class="sd">[2] Zbigniew Puchała, Łukasz Pawela, Aleksandra Krawiec, Ryszard Kukulski, &quot;Strategies for optimal single-shot</span>
<span class="sd">discrimination of quantum measurements&quot;, Phys. Rev. A 98, 042103 (2018), https://arxiv.org/abs/1804.05856</span>

<span class="sd">[3] T. Weissman, E. Ordentlich, G. Seroussi, S. Verdul, and M. J. Weinberger, Technical Report HPL-2003-97R1,</span>
<span class="sd">Hewlett-Packard Labs (2003).</span>

<span class="sd">[4] John Smolin, Jay M. Gambetta, Graeme Smith, &quot;Maximum Likelihood, Minimum Effort&quot;, Phys. Rev. Lett. 108, 070502</span>
<span class="sd">(2012), https://arxiv.org/abs/1106.5458</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">cmath</span> <span class="k">as</span> <span class="nn">c</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">QREM.functions_qrem</span> <span class="k">import</span> <span class="n">ancillary_functions</span> <span class="k">as</span> <span class="n">anf</span>
<span class="kn">import</span> <span class="nn">qiskit</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="k">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="n">epsilon</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span>


<div class="viewcode-block" id="PauliEigenkets"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.PauliEigenkets">[docs]</a><span class="k">class</span> <span class="nc">PauliEigenkets</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">ZERO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">ONE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">X_PLUS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Y_PLUS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">X_MINUS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">Y_MINUS</span> <span class="o">=</span> <span class="mi">5</span></div>


<div class="viewcode-block" id="get_pauli_eigenket"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_pauli_eigenket">[docs]</a><span class="k">def</span> <span class="nf">get_pauli_eigenket</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">ZERO</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">z</span> <span class="o">==</span> <span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">ONE</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">z</span> <span class="o">==</span> <span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">X_PLUS</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">z</span> <span class="o">==</span> <span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">Y_PLUS</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">z</span> <span class="o">==</span> <span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">X_MINUS</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">z</span> <span class="o">==</span> <span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">Y_MINUS</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Wrong state index. Expected: 0 - 5. Got: </span><span class="si">{z}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">state</span></div>


<span class="n">pauli_probe_eigenkets</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">get_pauli_eigenket</span><span class="p">(</span><span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">ZERO</span><span class="p">),</span>
    <span class="n">get_pauli_eigenket</span><span class="p">(</span><span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">ONE</span><span class="p">),</span>
    <span class="n">get_pauli_eigenket</span><span class="p">(</span><span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">X_PLUS</span><span class="p">),</span>
    <span class="n">get_pauli_eigenket</span><span class="p">(</span><span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">X_MINUS</span><span class="p">),</span>
    <span class="n">get_pauli_eigenket</span><span class="p">(</span><span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">Y_PLUS</span><span class="p">),</span>
    <span class="n">get_pauli_eigenket</span><span class="p">(</span><span class="n">PauliEigenkets</span><span class="o">.</span><span class="n">Y_MINUS</span><span class="p">)</span>
<span class="p">]</span>


<div class="viewcode-block" id="check_if_projector_is_in_computational_basis"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.check_if_projector_is_in_computational_basis">[docs]</a><span class="k">def</span> <span class="nf">check_if_projector_is_in_computational_basis</span><span class="p">(</span><span class="n">projector</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">projector</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">computational_basis_projectors</span> <span class="o">=</span> <span class="n">computational_projectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">base_projector</span> <span class="ow">in</span> <span class="n">computational_basis_projectors</span><span class="p">:</span>
        <span class="n">projectors_difference</span> <span class="o">=</span> <span class="n">base_projector</span> <span class="o">-</span> <span class="n">projector</span>  <span class="c1"># independent from global phase</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">projectors_difference</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="computational_projectors"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.computational_projectors">[docs]</a><span class="k">def</span> <span class="nf">computational_projectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">get_density_matrix</span><span class="p">(</span><span class="n">computational_basis</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span> <span class="o">**</span> <span class="n">n</span><span class="p">)]</span></div>


<div class="viewcode-block" id="computational_basis"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.computational_basis">[docs]</a><span class="k">def</span> <span class="nf">computational_basis</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">m_d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">**</span> <span class="n">n</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m_d</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eye</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">m_d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m_d</span><span class="p">)]</span></div>


<div class="viewcode-block" id="get_density_matrix"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_density_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_density_matrix</span><span class="p">(</span><span class="n">ket</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ket</span> <span class="o">@</span> <span class="n">ket_to_bra</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span></div>


<div class="viewcode-block" id="ket_to_bra"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.ket_to_bra">[docs]</a><span class="k">def</span> <span class="nf">ket_to_bra</span><span class="p">(</span><span class="n">ket</span><span class="p">):</span>
    <span class="n">bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">getH</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bra</span></div>


<div class="viewcode-block" id="get_unitary_change_state"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_unitary_change_state">[docs]</a><span class="k">def</span> <span class="nf">get_unitary_change_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">check_if_projector_is_in_computational_basis</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">anf</span><span class="o">.</span><span class="n">pauli_sigmas</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m_a</span><span class="p">,</span> <span class="n">m_u</span> <span class="o">=</span> <span class="n">anf</span><span class="o">.</span><span class="n">spectral_decomposition</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">m_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">determinant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">m_a</span><span class="p">)</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="n">determinant</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>

        <span class="n">m_u</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_u</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">getH</span><span class="p">(</span><span class="n">m_u</span><span class="p">)</span></div>


<div class="viewcode-block" id="euler_angles_1q"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.euler_angles_1q">[docs]</a><span class="k">def</span> <span class="nf">euler_angles_1q</span><span class="p">(</span><span class="n">unitary_matrix</span><span class="p">):</span>
    <span class="c1"># TODO FBM: This is slightly modified copied qiskit function</span>
    <span class="n">_CUTOFF_PRECISION</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;Compute Euler angles for single-qubit gate.</span>

<span class="sd">    Find angles (theta, phi, lambda) such that</span>
<span class="sd">    unitary_matrix = phase * Rz(phi) * Ry(theta) * Rz(lambda)</span>

<span class="sd">    Args:</span>
<span class="sd">        unitary_matrix (ndarray): 2x2 unitary matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (theta, phi, lambda) Euler angles of SU(2)</span>

<span class="sd">    Raises:</span>
<span class="sd">        QiskitError: if unitary_matrix not 2x2, or failure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">unitary_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;euler_angles_1q: expected 2x2 matrix&quot;</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">unitary_matrix</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">*</span> <span class="n">unitary_matrix</span>  <span class="c1"># U in SU(2)</span>
    <span class="c1"># OpenQASM SU(2) parameterization:</span>
    <span class="c1"># U[0, 0] = exp(-i_index(phi+lambda)/2) * cos(theta/2)</span>
    <span class="c1"># U[0, 1] = -exp(-i_index(phi-lambda)/2) * sin(theta/2)</span>
    <span class="c1"># U[1, 0] = exp(i_index(phi-lambda)/2) * sin(theta/2)</span>
    <span class="c1"># U[1, 1] = exp(i_index(phi+lambda)/2) * cos(theta/2)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># Find phi and lambda</span>
    <span class="n">phiplambda</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">phimlambda</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiplambda</span> <span class="o">+</span> <span class="n">phimlambda</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">lamb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiplambda</span> <span class="o">-</span> <span class="n">phimlambda</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># Check the solution</span>
    <span class="n">Rzphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">Rytheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)],</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">Rzlambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">lamb</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">lamb</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rzphi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rytheta</span><span class="p">,</span> <span class="n">Rzlambda</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="n">U</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_CUTOFF_PRECISION</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;compiling.euler_angles_1q incorrect result norm(V-U)=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span>
                         <span class="nb">format</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="n">U</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">lamb</span></div>


<div class="viewcode-block" id="get_su2_parametrizing_angles"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_su2_parametrizing_angles">[docs]</a><span class="k">def</span> <span class="nf">get_su2_parametrizing_angles</span><span class="p">(</span><span class="n">m_a</span><span class="p">):</span>
    <span class="c1"># Get three angles theta, phi, lambda which parametrize single-qubit unitary from SU(2)</span>

    <span class="k">if</span> <span class="n">is_pauli_x</span><span class="p">(</span><span class="n">m_a</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">anf</span><span class="o">.</span><span class="n">identity_check</span><span class="p">(</span><span class="n">m_a</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>

    <span class="n">m_a</span> <span class="o">=</span> <span class="n">anf</span><span class="o">.</span><span class="n">thresh</span><span class="p">(</span><span class="n">m_a</span><span class="p">)</span>
    <span class="n">eps_angles</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">determinant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">m_a</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="n">determinant</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">m_a</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">m_a</span>

    <span class="n">decomposer</span> <span class="o">=</span> <span class="n">qiskit</span><span class="o">.</span><span class="n">quantum_info</span><span class="o">.</span><span class="n">synthesis</span><span class="o">.</span><span class="n">one_qubit_decompose</span><span class="o">.</span><span class="n">OneQubitEulerDecomposer</span><span class="p">()</span>

    <span class="n">euler_theta_phi_lambda</span> <span class="o">=</span> <span class="n">decomposer</span><span class="o">.</span><span class="n">angles</span><span class="p">(</span><span class="n">m_a</span><span class="p">)</span>

    <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">euler_theta_phi_lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">euler_theta_phi_lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">euler_theta_phi_lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps_angles</span><span class="p">:</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">angles</span></div>


<div class="viewcode-block" id="is_pauli_x"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.is_pauli_x">[docs]</a><span class="k">def</span> <span class="nf">is_pauli_x</span><span class="p">(</span><span class="n">m_a</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">anf</span><span class="o">.</span><span class="n">zero_check</span><span class="p">(</span><span class="n">m_a</span> <span class="o">-</span> <span class="n">anf</span><span class="o">.</span><span class="n">pauli_sigmas</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="k">else</span> <span class="kc">False</span></div>


<span class="c1"># prepare unitaries which are to be implemented to change computational basis initial state of qubits (assuming</span>
<span class="c1"># |0000...0&gt; initial state) for chosen probe states. Here we assume perfect qubit initialization.</span>
<div class="viewcode-block" id="get_unitary_change_ket_qubit"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_unitary_change_ket_qubit">[docs]</a><span class="k">def</span> <span class="nf">get_unitary_change_ket_qubit</span><span class="p">(</span><span class="n">ket</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">get_density_matrix</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_if_projector_is_in_computational_basis</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">anf</span><span class="o">.</span><span class="n">pauli_sigmas</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ket</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ket_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ket_perp</span> <span class="o">=</span> <span class="n">ket_comp</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">ket_comp</span><span class="p">,</span> <span class="n">ket</span><span class="p">)</span> <span class="o">*</span> <span class="n">ket</span>
        <span class="n">ket_perp</span> <span class="o">=</span> <span class="n">ket_perp</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ket_perp</span><span class="p">)</span>
        <span class="n">U</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ket_perp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">determinant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="n">determinant</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">U</span>

        <span class="k">return</span> <span class="n">U</span></div>

<div class="viewcode-block" id="get_enumerated_rev_map_from_indices"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_enumerated_rev_map_from_indices">[docs]</a><span class="k">def</span> <span class="nf">get_enumerated_rev_map_from_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>

    <span class="c1">#TODO: move this function somewhere else</span>
    <span class="n">enumerated_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
    <span class="n">rev_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">enumerated_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">rev_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">k</span>
    <span class="k">return</span> <span class="n">rev_map</span></div>


<div class="viewcode-block" id="bit_strings"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.bit_strings">[docs]</a><span class="k">def</span> <span class="nf">bit_strings</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">rev</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate outcome bitstrings for number_of_qubits-qubits.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int): the number of qubits.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list:  list of bitstrings ordered as follows:</span>
<span class="sd">        Example: number_of_qubits=2 returns [&#39;00&#39;, &#39;01&#39;, &#39;10&#39;, &#39;11&#39;].</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">form</span> <span class="o">==</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="nb">bin</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="nb">bin</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">form</span> <span class="o">==</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>

            <span class="k">return</span> <span class="p">[(</span><span class="nb">list</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="nb">list</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))]</span></div>


<div class="viewcode-block" id="register_names_qubits"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.register_names_qubits">[docs]</a><span class="k">def</span> <span class="nf">register_names_qubits</span><span class="p">(</span><span class="n">qs</span><span class="p">,</span>
                          <span class="n">qrs</span><span class="p">,</span>
                          <span class="n">rev</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#TODO: move this function somewhere else</span>
    <span class="k">if</span> <span class="n">qrs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">qrs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>

    <span class="n">all_names</span> <span class="o">=</span> <span class="n">bit_strings</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>
    <span class="n">not_used</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qrs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qs</span><span class="p">:</span>
            <span class="n">not_used</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="n">bad_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">not_used</span><span class="p">):</span>
            <span class="n">rev_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rev_name</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">):</span>
                <span class="n">bad_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">relevant_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_names</span><span class="p">:</span>
            <span class="n">relevant_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">relevant_names</span></div>




<div class="viewcode-block" id="calculate_total_variation_distance"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.calculate_total_variation_distance">[docs]</a><span class="k">def</span> <span class="nf">calculate_total_variation_distance</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Given two vectors calculate Total-Variation distance between them. See Refs. [1] and [2] for the relation</span>
<span class="sd">        between TV-distance and operational distance between quantum measurements.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param p: numpy vector</span>
<span class="sd">        :param q: numpy vector</span>

<span class="sd">    Returns:</span>
<span class="sd">         Total variation distance between vectors q and p.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></div>


<span class="c1"># Done</span>
<div class="viewcode-block" id="get_off_diagonal_from_matrix"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_off_diagonal_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_off_diagonal_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Calculates and returns off-diagonal part of given matrix.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        :param matrix: Matrix for which off-diagonal part shall be calculated.</span>
<span class="sd">    Return:</span>
<span class="sd">        Off-diagonal part of the matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix_dimension</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">matrix_off_diagonal</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matrix_dimension</span><span class="p">):</span>
        <span class="c1"># set diagonal element to zero</span>
        <span class="n">matrix_off_diagonal</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">matrix_off_diagonal</span></div>


<span class="c1"># Done</span>
<div class="viewcode-block" id="get_off_diagonal_povm_part"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_off_diagonal_povm_part">[docs]</a><span class="k">def</span> <span class="nf">get_off_diagonal_povm_part</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Get the off-diagonal part of each of POVM&#39;s effects.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param povm: POVM - list of matrices representing POVM&#39;s effects.</span>

<span class="sd">    Return:</span>
<span class="sd">        List of np.ndarrays representing off-diagonal parts of POVM&#39;s effects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># implement function get_off_diagonal_from_matrix for each effect Mi in povm</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">get_off_diagonal_from_matrix</span><span class="p">(</span><span class="n">Mi</span><span class="p">)</span> <span class="k">for</span> <span class="n">Mi</span> <span class="ow">in</span> <span class="n">povm</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_diagonal_povm_part"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_diagonal_povm_part">[docs]</a><span class="k">def</span> <span class="nf">get_diagonal_povm_part</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        From given povm get only diagonal part as  list.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param povm: POVM from effects of which diagonal parts shall be extracted.</span>

<span class="sd">    Return:</span>
<span class="sd">        List of numpy arrays representing diagonal parts of given POVM.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">effect</span><span class="p">))</span> <span class="k">for</span> <span class="n">effect</span> <span class="ow">in</span> <span class="n">povm</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_classical_part_of_the_noise"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_classical_part_of_the_noise">[docs]</a><span class="k">def</span> <span class="nf">get_classical_part_of_the_noise</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        From given povm get stochastic map describing classical part of the noise.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param povm: POVM from effects of which diagonal parts shall be extracted.</span>

<span class="sd">    Return:</span>
<span class="sd">        List of numpy arrays representing diagonal parts of given POVM.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diagonal_parts</span> <span class="o">=</span> <span class="n">get_diagonal_povm_part</span><span class="p">(</span><span class="n">povm</span><span class="p">)</span>

    <span class="n">noise_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">povm</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">povm</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">column_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">povm</span><span class="p">)):</span>
        <span class="c1"># print(diagonal_parts[column_index])</span>
        <span class="n">noise_matrix</span><span class="p">[</span><span class="n">column_index</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal_parts</span><span class="p">[</span><span class="n">column_index</span><span class="p">])[:]</span><span class="o">.</span><span class="n">real</span>


    <span class="k">return</span> <span class="n">noise_matrix</span></div>

<div class="viewcode-block" id="get_coherent_part_of_the_noise"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_coherent_part_of_the_noise">[docs]</a><span class="k">def</span> <span class="nf">get_coherent_part_of_the_noise</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Get the off-diagonal part of each of POVM&#39;s effects.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param povm: POVM - list of matrices representing POVM&#39;s effects.</span>

<span class="sd">    Return:</span>
<span class="sd">        List of np.ndarrays representing off-diagonal parts of POVM&#39;s effects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">get_off_diagonal_povm_part</span><span class="p">(</span><span class="n">povm</span><span class="p">)</span></div>
    





<div class="viewcode-block" id="is_valid_probability_vector"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.is_valid_probability_vector">[docs]</a><span class="k">def</span> <span class="nf">is_valid_probability_vector</span><span class="p">(</span><span class="n">examined_vector</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Checks if given vector is valid probability vector i_index.e. has only positive values that sums to 1.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param examined_vector: Vector of probabilities for which the validity is checked.</span>
<span class="sd">        :param threshold: Error cluster_threshold when determining probabilities sum condition.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Information whether examined_vector is valid probability vector or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">examined_vector</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">values_sum</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">values_sum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span></div>


<div class="viewcode-block" id="find_closest_prob_vector"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.find_closest_prob_vector">[docs]</a><span class="k">def</span> <span class="nf">find_closest_prob_vector</span><span class="p">(</span><span class="n">quasiprobability_vector</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Given quasiprobability vector (here it means: vector which elements sum up to 1 but some of them are</span>
<span class="sd">        negative), find the closest probability vector in Euclidean norm (2-norm). Here we use fast algorithm from</span>
<span class="sd">        Ref. [4] and use the fact that probability distributions are special case of quantum states (namely,</span>
<span class="sd">        diagonal quantum states) and fact that for diagonal matrices 2-norm between them is the same as 2-norm</span>
<span class="sd">        between vectors created from their diagonal elements.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param quasiprobability_vector: Quasiprobability vector for which closest probability vector will be found.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Probability vector closest to quasiprobability_vector in Euclidean norm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quasiprobability_vector</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quasiprobability_vector</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quasiprobability_vector</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">))):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">quasiprobability_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># format vector properly</span>
    <span class="c1"># TODO: we probably don&#39;t need it here</span>
    <span class="n">quasiprobability_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quasiprobability_vector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># copy part of the vector</span>
    <span class="n">p000</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">quasiprobability_vector</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># For algorithm to work we need to rearrange probability vector elements, so we need to keep track of their</span>
    <span class="c1"># initial ordering</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">p000</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>

    <span class="c1"># Sort elements in descending order</span>
    <span class="n">p1_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Initiate accumulator</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># go from the i_index=d</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

        <span class="c1"># get vector element</span>
        <span class="n">mu_i</span> <span class="o">=</span> <span class="n">p1_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if mu_i +a/(i_index+1) is negative, do the following:</span>
        <span class="k">if</span> <span class="n">mu_i</span> <span class="o">+</span> <span class="n">a</span> <span class="o">/</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># add mu_i to accumulator</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="n">mu_i</span>

            <span class="c1"># set vector element to 0</span>
            <span class="n">p1_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># otherwise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># update proper elements of probability vector</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">p1_sorted</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">/</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># finish algorithm - everything is positive now</span>
            <span class="k">break</span>

    <span class="c1"># return to initial order</span>
    <span class="n">ordered_p</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p1_sorted</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># get rid of indices</span>
    <span class="n">p_good_format</span> <span class="o">=</span> <span class="p">[</span><span class="n">ordered_p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_good_format</span><span class="p">)</span></div>


<div class="viewcode-block" id="permute_matrix"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.permute_matrix">[docs]</a><span class="k">def</span> <span class="nf">permute_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">transposition</span><span class="p">):</span>
    <span class="c1"># Swap qubits (subspaces) in 2**number_of_qubits dimensional matrix</span>
    <span class="c1"># number_of_qubits - number of qubits</span>
    <span class="c1"># transposition - which qubits to SWAP.</span>
    <span class="c1"># IMPORTANT: in transposition they are numbered from 1</span>

    <span class="n">swap</span> <span class="o">=</span> <span class="n">qubit_swap</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">transposition</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">swap</span> <span class="o">@</span> <span class="n">matrix</span> <span class="o">@</span> <span class="n">swap</span></div>


<div class="viewcode-block" id="qubit_swap"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.qubit_swap">[docs]</a><span class="k">def</span> <span class="nf">qubit_swap</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">transposition</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="c1"># create swap between two qubits in 2**number_of_qubits dimensional space</span>
    <span class="c1"># labels inside transpositions start from 1.</span>

    <span class="n">D</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n</span>
    <span class="c1"># renumerate for Python convention</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">transposition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">transposition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">bin</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))]</span>

    <span class="n">new_names</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="c1"># exchange classical register bits with labels in transposition</span>
    <span class="c1"># this defines new order in classical register which respects qubit SWAP</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">)):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_names</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">string</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">new_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">string</span><span class="p">])</span>

    <span class="n">transformation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
        <span class="n">bit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">new_names</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># if we need to change the bit, let&#39;s do this</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">transformation</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">transformation</span><span class="p">[</span><span class="n">bit</span><span class="p">,</span> <span class="n">bit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">transformation</span><span class="p">[</span><span class="n">bit</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">transformation</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">bit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">transformation</span></div>

<div class="viewcode-block" id="reorder_classical_register"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.reorder_classical_register">[docs]</a><span class="k">def</span> <span class="nf">reorder_classical_register</span><span class="p">(</span><span class="n">new_order</span><span class="p">):</span>
    <span class="c1"># reorder classical register according to new_order.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>

    <span class="c1"># get standard classical register</span>
    <span class="n">standard_register</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">bin</span><span class="p">(</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">))]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">sort_bitstring</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">new_order</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">standard_register</span><span class="p">]</span></div>


<div class="viewcode-block" id="sort_things"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.sort_things">[docs]</a><span class="k">def</span> <span class="nf">sort_things</span><span class="p">(</span><span class="n">stuff_to_sort</span><span class="p">,</span> <span class="n">according_to_what</span><span class="p">):</span>
    <span class="c1"># Sort stuff according to some other stuff assuming that the stuff_to_sort is sorted in natural order (0, 1, 2, ...)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">according_to_what</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">stuff_to_sort</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span></div>


<div class="viewcode-block" id="sort_bitstring"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.sort_bitstring">[docs]</a><span class="k">def</span> <span class="nf">sort_bitstring</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
    <span class="c1"># sort bits in string according to new_order</span>
    <span class="n">sorted_string</span> <span class="o">=</span> <span class="n">sort_things</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="p">),</span> <span class="n">new_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sorted_string</span><span class="p">])</span></div>


<div class="viewcode-block" id="reorder_probabilities"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.reorder_probabilities">[docs]</a><span class="k">def</span> <span class="nf">reorder_probabilities</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
    <span class="c1"># sort elements of probabilities vector according to new_order defined for bits</span>

    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>
    <span class="n">array_format</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">array_format</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># get classical register according sorted to new order</span>
    <span class="n">new_classical_register</span> <span class="o">=</span> <span class="n">reorder_classical_register</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
    <span class="c1"># sort probabilities entries according to new register</span>
    <span class="n">sorted_probs</span> <span class="o">=</span> <span class="n">sort_things</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">new_classical_register</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">array_format</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sorted_probs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_probs</span></div>


<div class="viewcode-block" id="get_CBT_norm"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_CBT_norm">[docs]</a><span class="k">def</span> <span class="nf">get_CBT_norm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">rev</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cvxopt</span> <span class="k">as</span> <span class="nn">cvx</span>
    <span class="kn">import</span> <span class="nn">picos</span> <span class="k">as</span> <span class="nn">pic</span>
    <span class="c1"># Get completely bounded trace norm of Choi-matrix J representing quantum channel from number_of_qubits-dimensional space to m-dimensional space</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">cvx</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">),</span> <span class="n">vtype</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

    <span class="n">rho0</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s2">&quot;rho0&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">vtype</span><span class="o">=</span><span class="s1">&#39;hermitian&#39;</span><span class="p">)</span>
    <span class="n">rho1</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s2">&quot;rho1&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">vtype</span><span class="o">=</span><span class="s1">&#39;hermitian&#39;</span><span class="p">)</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">rho0</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">rho1</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">prob</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">pic</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">pic</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># TODO FBM: tests which conention is good.</span>
        <span class="c1"># TODO FBM: add reference to paper</span>

        <span class="c1"># This is convention REVERSED with respect to the paper,</span>
        <span class="c1"># and seems that this is a proper one????</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">rho1</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">rho0</span><span class="p">)</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">rho1</span><span class="p">)</span>

    <span class="n">F</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">trace</span><span class="p">((</span><span class="n">J</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">pic</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">H</span><span class="p">))</span>

    <span class="n">prob</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(((</span><span class="n">C0</span> <span class="o">&amp;</span> <span class="n">X</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">H</span> <span class="o">&amp;</span> <span class="n">C1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">prob</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>

    <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;optimal&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#        print(&#39;solution optimal&#39;)</span>
        <span class="mi">1</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;optimal&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;uknown_if_solution_optimal&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;solution not found&#39;</span><span class="p">)</span>

    <span class="n">cbt_norm</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">obj_value</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cbt_norm</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mf">0.00001</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cbt_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">cbt_norm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cbt_norm</span></div>


<div class="viewcode-block" id="get_POVM_choi"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_POVM_choi">[docs]</a><span class="k">def</span> <span class="nf">get_POVM_choi</span><span class="p">(</span><span class="n">POVM</span><span class="p">):</span>
    <span class="c1"># get Choi matrix of POVM channel</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">POVM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">POVM</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">J</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">POVM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="operational_distance_POVMs"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.operational_distance_POVMs">[docs]</a><span class="k">def</span> <span class="nf">operational_distance_POVMs</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="n">difference</span> <span class="o">=</span> <span class="p">([</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;CBTN&#39;</span><span class="p">):</span>
        <span class="c1"># this calculates completely bounded trace norm of the channel which is the upper bound for operational distance</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">get_POVM_choi</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span>
        <span class="n">cbt_norm</span> <span class="o">=</span> <span class="n">get_CBT_norm</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cbt_norm</span> <span class="o">/</span> <span class="mi">2</span>


    <span class="k">elif</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">):</span>
        <span class="c1"># calculate operational distance directly via bruteforce search over subsets_list of outcomes</span>
        <span class="n">biggest_norm</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">current_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">current_list</span><span class="p">:</span>
                <span class="n">current_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="n">current_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">current_sum</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">current_norm</span> <span class="o">&gt;</span> <span class="n">biggest_norm</span><span class="p">):</span>
                    <span class="n">biggest_norm</span> <span class="o">=</span> <span class="n">current_norm</span>

        <span class="k">return</span> <span class="n">biggest_norm</span></div>


<div class="viewcode-block" id="get_statistical_error_bound"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_statistical_error_bound">[docs]</a><span class="k">def</span> <span class="nf">get_statistical_error_bound</span><span class="p">(</span><span class="n">number_of_measurement_outcomes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                <span class="n">number_of_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                <span class="n">statistical_error_mistake_probability</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                <span class="n">number_of_marginals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Get upper bound for tv-distance of estimated probability distribution from ideal one. See Ref. [3] for</span>
<span class="sd">        details.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param number_of_measurement_outcomes: Number of outcomes in probabiility distribution (2^(number_of_qubits) for standard measurement)</span>
<span class="sd">        :param number_of_samples: Number of samples for experiment for which statistical error bound is being calculated.</span>
<span class="sd">        :param statistical_error_mistake_probability: Parameter describing infidelity of returned error bound.</span>

<span class="sd">    Return:</span>
<span class="sd">        Statistical error upper bound in total variance distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">number_of_marginals</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">number_of_marginals</span> <span class="o">=</span> <span class="mi">1</span>


    <span class="k">if</span> <span class="n">number_of_measurement_outcomes</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
        <span class="c1"># for small number of outcomes &quot;-2&quot; factor is not negligible</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">number_of_measurement_outcomes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
             <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">statistical_error_mistake_probability</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number_of_marginals</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">number_of_samples</span>
        <span class="p">)</span>
        <span class="c1"># for high number of outcomes &quot;-2&quot; factor is negligible</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">number_of_measurement_outcomes</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">statistical_error_mistake_probability</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number_of_marginals</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">number_of_samples</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_coherent_error_bound"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_coherent_error_bound">[docs]</a><span class="k">def</span> <span class="nf">get_coherent_error_bound</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Get distance between diagonal part of the POVM and the whole POVM. This quantity might be interpreted as a</span>
<span class="sd">        measure of &quot;non-classicality&quot; or coherence present in measurement noise. See Ref. [1] for details.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param povm: POVM for which non-classicality will be determined.</span>
<span class="sd">    Return:</span>
<span class="sd">        Coherent error bound for given POVM.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">operational_distance_POVMs</span><span class="p">(</span><span class="n">povm</span><span class="p">,</span> <span class="n">get_diagonal_povm_part</span><span class="p">(</span><span class="n">povm</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_correction_error_bound_from_data_and_statistical_error"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_correction_error_bound_from_data_and_statistical_error">[docs]</a><span class="k">def</span> <span class="nf">get_correction_error_bound_from_data_and_statistical_error</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                                               <span class="n">correction_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                               <span class="n">statistical_error_bound</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                                               <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>
<span class="sd">            Get upper bound for the correction error using classical error-mitigation via &quot;correction matrix&quot;.</span>

<span class="sd">            Error arises from three factors - non-classical part of the noise, statistical fluctuations and eventual</span>
<span class="sd">            unphysical &quot;first-guess&quot; (quasi-)probability vector after the correction.</span>

<span class="sd">            This upper bound tells us quantitatively what is the maximal TV-distance of the corrected probability vector</span>
<span class="sd">            from the ideal probability distribution that one would have obtained if there were no noise and the</span>
<span class="sd">            infinite-size statistics.</span>

<span class="sd">            See Ref. [1] for details.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            :param povm: POVM representing measurement device.</span>
<span class="sd">            :param correction_matrix: Correction matrix obtained via out Error Mitigator object.</span>
<span class="sd">            :param statistical_error_bound: Statistical error bound (epsilon in paper).</span>
<span class="sd">            confidence with which we state the upper bound. See Ref. [3] for details.</span>
<span class="sd">            :param alpha: distance between eventual unphysical &quot;first-guess&quot; quasiprobability vector and the closest</span>
<span class="sd">            physical one. default is 0 (which corresponds to situation in which corrected vector was proper probability</span>
<span class="sd">            vector).</span>


<span class="sd">        Return:</span>
<span class="sd">            Upper bound for correction error.</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="n">norm_of_correction_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">correction_matrix</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">coherent_error_bound</span> <span class="o">=</span> <span class="n">get_coherent_error_bound</span><span class="p">(</span><span class="n">povm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">norm_of_correction_matrix</span> <span class="o">*</span> <span class="p">(</span><span class="n">coherent_error_bound</span> <span class="o">+</span> <span class="n">statistical_error_bound</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span></div>


<div class="viewcode-block" id="get_correction_error_bound_from_data"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_correction_error_bound_from_data">[docs]</a><span class="k">def</span> <span class="nf">get_correction_error_bound_from_data</span><span class="p">(</span><span class="n">povm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                         <span class="n">correction_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                         <span class="n">number_of_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                         <span class="n">error_probability</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                         <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Get upper bound for the correction error using classical error-mitigation via &quot;correction matrix&quot;.</span>

<span class="sd">        Error arises from three factors - non-classical part of the noise, statistical fluctuations and eventual</span>
<span class="sd">        unphysical &quot;first-guess&quot; (quasi-)probability vector after the correction.</span>

<span class="sd">        This upper bound tells us quantitatively what is the maximal TV-distance of the corrected probability vector</span>
<span class="sd">        from the ideal probability distribution that one would have obtained if there were no noise and the</span>
<span class="sd">        infinite-size statistics.</span>

<span class="sd">        See Ref. [0] for details.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param povm: POVM representing measurement device.</span>
<span class="sd">        :param correction_matrix: Correction matrix obtained via out Error Mitigator object.</span>
<span class="sd">        :param number_of_samples: number of samples (in qiskit language number of &quot;shots&quot;).</span>
<span class="sd">        :param error_probability: probability with which statistical upper bound is not correct. In other word, 1-mu is</span>
<span class="sd">        confidence with which we state the upper bound. See Ref. [3] for details.</span>
<span class="sd">        :param alpha: distance between eventual unphysical &quot;first-guess&quot; quasiprobability vector and the closest</span>
<span class="sd">        physical one. default is 0 (which corresponds to situation in which corrected vector was proper probability</span>
<span class="sd">        vector).</span>


<span class="sd">    Return:</span>
<span class="sd">        Upper bound for correction error.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">povm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">norm_of_correction_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">correction_matrix</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">statistical_error_bound</span> <span class="o">=</span> <span class="n">get_statistical_error_bound</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="p">,</span> <span class="n">error_probability</span><span class="p">)</span>
    <span class="n">coherent_error_bound</span> <span class="o">=</span> <span class="n">get_coherent_error_bound</span><span class="p">(</span><span class="n">povm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">norm_of_correction_matrix</span> <span class="o">*</span> <span class="p">(</span><span class="n">coherent_error_bound</span> <span class="o">+</span> <span class="n">statistical_error_bound</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span></div>


<div class="viewcode-block" id="get_correction_error_bound_from_parameters"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_correction_error_bound_from_parameters">[docs]</a><span class="k">def</span> <span class="nf">get_correction_error_bound_from_parameters</span><span class="p">(</span><span class="n">norm_of_correction_matrix</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                               <span class="n">statistical_error_bound</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                               <span class="n">coherent_error_bound</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                               <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        See description of function &quot;get_correction_error_bound_from_data&quot;. This function can be used if one has the</span>
<span class="sd">        proper parameters already calculated and wishes to not repeat it (for example, in case of calculating something</span>
<span class="sd">        in the loop).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        :param norm_of_correction_matrix : 1-&gt;1 norm of correction matrix (it is not trace norm!), see Ref. [0],</span>
<span class="sd">        or definition of np.linalg.norm(X,ord=1)</span>
<span class="sd">        :param statistical_error_bound: upper bound for statistical errors. Can be calculated using function</span>
<span class="sd">        get_statistical_error_bound.</span>
<span class="sd">        :param coherent_error_bound: magnitude of coherent part of the noise. Can be calculated using function</span>
<span class="sd">        get_coherent_error_bound.</span>
<span class="sd">        :param alpha: distance between eventual unphysical &quot;first-guess&quot; quasi-probability vector and the closest</span>
<span class="sd">        physical one. default is 0 (which corresponds to situation in which corrected vector was proper probability</span>
<span class="sd">        vector)</span>

<span class="sd">    Return:</span>
<span class="sd">        Upper bound for correction error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">norm_of_correction_matrix</span> <span class="o">*</span> <span class="p">(</span><span class="n">coherent_error_bound</span> <span class="o">+</span> <span class="n">statistical_error_bound</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span></div>


<div class="viewcode-block" id="counts_dict_to_frequencies_vector"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.counts_dict_to_frequencies_vector">[docs]</a><span class="k">def</span> <span class="nf">counts_dict_to_frequencies_vector</span><span class="p">(</span><span class="n">count_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">reverse_order</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        Generates and returns vector of frequencies basing on given counts dict. Mostly used with qiskit data.</span>
<span class="sd">    :param count_dict: Counts dict. Possibly from qiskit job.</span>
<span class="sd">    :return frequencies: Frequencies list for possible states in ascending order.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frequencies</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">qubits_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">count_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Number of qubits in given experiment counts.</span>
    <span class="n">possible_outcomes</span> <span class="o">=</span> <span class="n">get_possible_n_qubit_outcomes</span><span class="p">(</span><span class="n">qubits_number</span><span class="p">)</span>
    <span class="n">dict_keys</span> <span class="o">=</span> <span class="n">count_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>  <span class="c1"># So we don&#39;t call the method_name every time.</span>
    <span class="n">counts_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">outcome</span> <span class="ow">in</span> <span class="n">possible_outcomes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dict_keys</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">outcome</span><span class="p">):</span>
            <span class="n">frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count_dict</span><span class="p">[</span><span class="n">outcome</span><span class="p">])</span>
            <span class="n">counts_sum</span> <span class="o">+=</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">outcome</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)):</span>
        <span class="n">frequencies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">counts_sum</span>



    <span class="k">if</span> <span class="n">reverse_order</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reorder_probabilities</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubits_number</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frequencies</span></div>


<div class="viewcode-block" id="get_possible_n_qubit_outcomes"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_possible_n_qubit_outcomes">[docs]</a><span class="k">def</span> <span class="nf">get_possible_n_qubit_outcomes</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description:</span>
<span class="sd">        For given number of qubits number_of_qubits generates a list of possible outcome states</span>
<span class="sd">         (as strings) and returns them in</span>
<span class="sd">        ascending order. All states len is number_of_qubits.</span>
<span class="sd">    :param n: Number of qubits.</span>
<span class="sd">    :return: List of possible outcomes as strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">possible_outcomes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_value</span><span class="p">):</span>
        <span class="n">possible_outcomes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">possible_outcomes</span></div>


<div class="viewcode-block" id="get_noise_matrix_from_povm"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_noise_matrix_from_povm">[docs]</a><span class="k">def</span> <span class="nf">get_noise_matrix_from_povm</span><span class="p">(</span><span class="n">povm</span><span class="p">):</span>
    <span class="n">number_of_povm_outcomes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">povm</span><span class="p">)</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">povm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_of_povm_outcomes</span><span class="p">,</span> <span class="n">number_of_povm_outcomes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_povm_outcomes</span><span class="p">):</span>
        <span class="n">current_povm_effect</span> <span class="o">=</span> <span class="n">povm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># Get diagonal part of the effect. Here we remove eventual 0 imaginary part to avoid format conflicts</span>
        <span class="c1"># (diagonal elements of Hermitian matrices are real).</span>
        <span class="n">vec_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">current_povm_effect</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">)])</span>

        <span class="c1"># Add vector to transition matrix.</span>
        <span class="n">transition_matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vec_p</span><span class="p">[:]</span>

    <span class="k">return</span> <span class="n">transition_matrix</span></div>


<div class="viewcode-block" id="get_correction_matrix_from_povm"><a class="viewcode-back" href="../../../QREM.functions_qrem.html#QREM.functions_qrem.povmtools.get_correction_matrix_from_povm">[docs]</a><span class="k">def</span> <span class="nf">get_correction_matrix_from_povm</span><span class="p">(</span><span class="n">povm</span><span class="p">):</span>
    <span class="n">number_of_povm_outcomes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">povm</span><span class="p">)</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="n">povm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_of_povm_outcomes</span><span class="p">,</span> <span class="n">number_of_povm_outcomes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_povm_outcomes</span><span class="p">):</span>
        <span class="n">current_povm_effect</span> <span class="o">=</span> <span class="n">povm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># Get diagonal part of the effect. Here we remove eventual 0 imaginary part to avoid format conflicts</span>
        <span class="c1"># (diagonal elements of Hermitian matrices are real).</span>
        <span class="n">vec_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">current_povm_effect</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">)])</span>

        <span class="c1"># Add vector to transition matrix.</span>
        <span class="n">transition_matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">vec_p</span><span class="p">[:]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">transition_matrix</span><span class="p">)</span></div>





</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">QREM</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Filip B. Maciejewski, Tomasz Rybotycki, Oskar Słowik, Jan Tuziemski, Michał Oszmaniec.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>